---
layout: post
title: "C++算法描述"
subtitle: " \"C++算法描述\""
date: 2015-04-12 14:47:31
author: "Minato"
header-img: "img/post-bg-2015.jpg"
tags:
    - C++ 
    - 算法
---

# C++算法描述
 
## 算法

### 选择排序

* #### 原理描述
    * 找到数组中最小的元素，与第一个元素位置交换
    * 找剩下元素中最小的元素，与第二个元素位置交换
    * 不断选择剩余元素的最小值，依次与未排序位置交换
* #### 交换次数为N，效率取决于比较次数
* #### 长度为N时，需要进行N^2/2次比较和N次交换
* #### 代码描述

        //选择排序，不稳定，O（n^2）
        void selectSort(vector array,int size)
        {
        	int minIndex ;
        	for (int i = 0;i<size,i++) {
        		minIndex = i;
        		for (int j = i + 1; j < size; j++) {
        			if(array[minIndex] >array[j]){
        				//获取最小值的下标
        				minIndex = j;
        			}
        		}
        		if(minIndex != i){
        			//将每次遍历的最小值与当前的位置数进行交换
        			swap(array,i,minIndex);
        		}
        	}
        }

### 插入排序
* #### 原理
    * 从头往后遍历，跟进当前遍历的位置的后一位，从后往前再进行变量，**相邻** 两两位置比较进行交换
* #### 平均情况下，进行N^2/4次比较和N^2/4次交换
* #### 最坏情况下，进行N^2/2次比较和N^2/2次交换
* #### 代码
        
        //插入排序，稳定排序，O（n^2)
        void insertSort(T* array,int size){
        	for (int i = 1; i < size; i++) {
        		//从头进行累加个数比较
        		for (int j = i; j > 0; j--) {
        			//当前元素的个数内，从后向前比较，小数往前移动
        			if(array[j]<array[j-1]){
        				swap(array,j,j-1)
        			}
        		}
        	}
        }

### 希尔排序
* #### 原理
    * 在插入排序的基础上，在遍历时将相邻的对比排序修改成相隔H即可，使用不同的增量
    * 遍历数组，对相邻H的位置的元素进行对比交换后，形成多个h间隔的有序数组
    * 再对H间隔进行递减，继续排序操作，直到H间隔为0时完成全部排序
    * H的取值为3*H+1（最小值满足）>L/3，每次进行H/3的递减

### 归并排序
* #### 原理
    * 要将一个数组排序，先用递归的方法分成两半进行排序，再将结果进行合并
    * 递归到两个数比较，成为一个新的数组，再和下一组排序好的数组进行归并
* #### 优点
    * 将保证任意长度为N的数组，排序时间和NlogN成正比
* #### 缺点
    * 需要额外的空间，和N成正比
* #### 代码

        //归并排序，稳定排序，O（nlogn）
        void MergeSort(T* array, int size){
        	if(left < right){
        		int mid = (left + right)/2;
        		MergeSort(array,left,mid);
        		MergeSort(array,mid + 1,right);
        		//合并两条已经排序好的子链
        		Merge(array,left,mid,right);
        	}
        }
        
        void Merge(T* array,int left,int mid,int right){
        	T* temp = new T[right - left + 1];
        	int i = left,j = mid + 1,m = 0;
        	while (i <= mid && j <= right) {
        		if(array[i]<array[j]{
        			temp[m++] = array[i++];
        		}else{
        			temp[m++] = array[j++];
        		}
        	}
        	while (i <= mid) {
        		temp[m++] = array[i++];
        	}
        	while (j <= right) {
        		temp[m++] = array[j++];
        	}
        	for (int n = left,m = 0; n <= right; n++,m++) {
        		array[n] = temp[m];
        	}
        	delete temp;
        }

### 快速排序
* 原理
    * 取第一个元素，作为切分元素
    * 从数组的左端向右找出大于等于切分元素的值的下标
    * 从数组的右端向左找出小于切分元素的值的小标
    * 左右下标不等时对两个数值进行交换位置，继续移动下标查找
    * 左右下标相遇时，将切分元素和相遇的下标元素交换
    * 再以切分元素的位置分出左右两边数组，递归调用上面的步骤
* 优化
    * 使用大小居中的数值做切分元素
    * 对于小数组用插入排序比快速排序快
* 最多需要N^2/2次比较
* 平均需要2NInN次比较
* 代码

        //快速排序，不稳定排序，O（nlogn）
        void QuickSort(T* array,int left,int right){
        	if(left < right){
        		int i = left - 1,j = right + 1;
        		//取参考的数值
        		T mid = array[(left + right)/2];
        		while(true){
        			//检测标准数的左边，比他大的数的下标位置
        			while (array[++i]<mid) ;
        			//检测标准数的右边，比他小的数的下标位置
        			while (array[--j]>mid) ;
        			if(i >= j){
        				//左右两个坐标位置有交集则退出
        				break;
        			}
        			//将左边的大数和右边的小数交换位置
        			swap(array,i,j);
        		}
        		QuickSort(array,left,i-1);
        		QuickSort(array,j+1,right);
        	}
        }

### 堆排序
* #### 特点
    * 每个结点都大于等于他的两个子结点
    * 根结点是堆排序中最大结点、
    * 实现优先队列（插入元素和删除最大值）
* #### 原理
    * ##### 在堆构造阶段，将原始数组重新组织排序成一个堆
        * 从数组的中间值开始，往前遍历
        * 比较当前数值和两个子结点的大小，子节点大的话则上浮，当前值则下沉到子结点的位置
        * 再继续比较当前数值所在位置的子结点是否比其更大，是的话则继续下沉当前结点
        * 遍历到数组第一个元素则结束遍历，构造堆完成
    * ##### 在下沉排序阶段，从堆中按递减顺序取出所有元素并得到排序效果
        * 删除堆中顶端的最大元素，然后取数组最尾数填补堆顶，进行下沉排序
        * 排序完后继续上面操作
        * 等堆数据取完则排序结束
        * 下沉操作不超过2N次比较和N次交换
    * ##### 由下至上的堆有序化（上浮）
        * 当某个结点变得比父节点大时，或者插入一个新节点比父节点大，则交换他和父节点的位置
        * 可能比交换后的父节点大，则需要解析恢复并上移，直到遇到更大的父节点
        * 当结点不比父结点大时，堆的秩序则恢复了
    * ##### 由上至下的堆有序化（下沉）
        * 当某个结点比两个子节点小时，则更两个子结点比较，并交换位置
        * 直到他的两个子节点都比他小时，或到达堆的底部
    * ##### 插入元素
        * 将新元素插入到数组的末尾，进行上浮到合适的位置
    * ##### 删除最大值
        * 删除数组顶端的元素并用最后一个元素放在顶端，进行下沉到合适的位置
        

























------

Copyright 2015 WangLin
<!-- create time: 2015-04-12 14:47:31  -->

