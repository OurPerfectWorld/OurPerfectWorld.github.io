---
layout: post
title: "对象模型设计"
subtitle: " \"游戏对象模型\""
date: 2015-03-28 19:31:50
author: "Minato"
header-img: "img/post-bg-2015.jpg"
tags:
    - Cocos2d-X 
    - 游戏对象模型
---

# 游戏对象模型

<!-- create time: 2015-03-28 19:31:50  -->
----

## 以对象为中心的架构设计
* 特点：
    1. 借助面向对象语言的继承和重载，为所有的对象构建特定的类型定义
    2. 以对象为中心的架构，强调的是对象通常由一个特定的数据结构类型来定义
    3. 继承——is a的关系
    4. 组合——has a的关系（生命周期一致为合成，不一致为聚合）
* 存在的问题：
    1. 复杂的层次结构
        + 所有对象继承自基类，游戏对象类型越多，继承树越复杂
        + 继承树深导致难以阅读和修改，理解一个类的功能先要了解其父类功能
        + 理解和维护困难
    2. 分类学瓶颈
        + 继承树中对象的分类设计，基于特定的分类标准
        + 新需求可能造成与现有的分类标准冲突，如英雄拥有怪物的某些特性
    3. 多重继承
        + 新类型是几个现有类型的组合，导致拥有不必要的属性继承
    4. 冒泡效应
        + 当新需求破坏分类规则时，会把通用功能往基类移动，即冒泡效应
        + 导致父类最后有很多游戏对象的行为；也导致子类只定义感兴趣的行为，其他属性类型屏蔽但占据不必要的数据内存
    5. 恶性循环的重构


## 组件模型的架构设计
* 仍然是以对象为中心的设计，以合成的形式来组合对象
* 只有合成，没有继承
    1. 将每个功能分类成一个单一独立的接口，使用合成的方式组合成一个对象
    2. 单一功能的类成为组件，根据功能需要进行选择，维护和重构方便
* 组件的创建和拥有权
    + 类管理组件的生命周期，初始化时则必须知道要使用的组件
    + 实现方法：
        1. 对象继承GameObj，子类的构造函数中初始化自己感兴趣的组件
        2. 组件继承自基类，而GameObj拥有一个组件的链表或容器；则游戏对象不关心有哪些组件类型，并且可以拥有任意数量的组件——Unity3D的游戏对象架构设计
            * 好处：根据文本文件定义的游戏对象类型，决定游戏对象创建哪些组件
            

## 以属性为中心的架构设计
* 内存布局比较
    + 以对象为中心的内存布局
    
            * 对象1：
                位置（10，20，30）
                方向（左）
            * 对象2：
                位置（5，8，0）
                血量（20）
            * 对象3：
                方向（右）
                
    + 以属性为中心的内存布局，类似于数据库（与lua表结构的优化有些相似）
    
            * 位置：
                对象1（10，20，30）
                对象2（5，8，0）
            * 血量：
                对象2（20）
            * 方向：
                对象1（左）
                对象3（右）
            对象是属性的索引值，表明该属性属于哪个对象

* 以属性为中心的架构包含属性和行为，通过两种方式可以定义对象的行为
    + 通过属性类实现

            1、每个属性实现为一个类，包含属性数据的定义和行为
                如：代表血量的属性，定义血量的值，通过受伤扣血，血少死亡的成员函数来表现行为
            2、和组件的区别在于内存的分配上，组件实例分布于各个游戏对象中
            
    + 通过脚本实现
 
            1、每个属性对应一个脚本函数，通过脚本实现对象的行为
            2、游戏对象包含哪些属性，系统则运行属性对应的脚本来处理游戏对象行为
            3、例子：末日危城
            
* 优点
    1. 更高效利用内存
    2. 相同类型的属性实例在内存中是连续的存储的，成为数组化结构；对象模型的数据布局为结构化数组
    3. 更容易实现数据驱动，通过定义属性列表或者通过脚本添加新的属性类型来实现对象的创建
* 缺点
    1. 属性都在属性表中，调试不方便
    

## Entity Component System
* 特点：
    1. 以属性为中心，采用数据库类似的结构来存储对象
    2. 实现高度的数据驱动 
* 属性结构：
    * Entity
    
            1、表示游戏对象，只包含一个表示对象ID的唯一标识符
            2、拥有Component集合，不同类型的集合组成特定的游戏对象，Entity为属性
    
    * Component
    
            1、属性的数据部分，只包含一些get/set方法和内部数据处理方法，不含实例方法
            
    * System
        
            1、属性的行为方法，检测属性的值，但条件达到时进行发出通知事件
            2、由游戏循环驱动来修改游戏对象的状态，包含一个update方法
            
* 与组件模型的区别：
    * 属性的数据和行为是分开的，并且一一对应
    * 组件是同时包含数据和行为

* 分离数据和行为：
    * 好处
        1. 多个行为可能共享一些数据
        2. 内存布局上保证所有属性实例占据连续的内存空间，以对象的唯一标识符作为主key储存对象实例
        3. 行为从数据中分离，作为纯算法存在，不需要构建实例（实例的方法存在一个方法表中）；则一百个对象拥有某个属性时，该属性对应的方法地址则是一个，而不是一百个
    * 逻辑的更新过程
    
            每帧更新时，执行每个System行为的update方法
            一个System实例找到对应的一个Component实例
            每个Component实例对应的Entity执行逻辑更新，则将行为作用在Entity上

    * 数据驱动
        * 属性值
            * 将可能会修改的属性加入到数据表，一种对对象属性值的驱动
        * 对象结构
            * 驱动游戏对象的属性值
                * 需要修改摸个属性时，只需要单独修改相应的属性
            * 驱动游戏对象结构
                * 需要给对象新增一个行为时，只需要对该对象添加属性即可
        * 事件脚本


* 对象查找与消息的更新:
    * 根据唯一标识符查询对象
        * 存储对象名的hash值，便于查询。如 Node::setName &&     Node::getChildByName 
    * 根据类型查询
        * 在ECS中通过获取某个属性的实例来获取游戏对象。如 getAllEntitiesPosessingCom
    * 面向类型编程
        * 通过类型查找到对象的集合，再对拥有该属性类型的对象进行操作，即面向类型编程
        * 通过类型查找到对象，再由对象查找到该对象拥有的其他类型属性数据
    * 桶式更新
        * 原理：特定对象需要另外某个特定对象执行完所有更新状态之后才开始执行该对象的系统更新
        * 例如：Entity4需要等到Entity1更新完毕后再更新。
        * 在ECS中即对对象分组，称为桶，每个桶按从小到大的顺序进行更新，在Entity::setBucket中对对象设置一个桶号


------

Copyright 2015 WangLin

